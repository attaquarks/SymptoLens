import torch
import torch.nn as nn
from torchvision import models, transforms
from transformers import AutoTokenizer, AutoModel
from PIL import Image
import numpy as np
import json
from typing import List, Dict, Tuple, Any

TARGET_DISEASES = ["Influenza", "Lyme Disease", "Common Cold", "Eczema", "Conjunctivitis", "Bronchitis", "Pneumonia", "Skin Allergy", "Gastroenteritis"]
TEXT_ENCODER_MODEL_NAME = 'bert-base-uncased'
IMAGE_ENCODER_EMBEDDING_DIM = 2048 
TEXT_ENCODER_EMBEDDING_DIM = 768 

class TextEncoder(nn.Module):
    def __init__(self, model_name: str = TEXT_ENCODER_MODEL_NAME):
        super().__init__()
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModel.from_pretrained(model_name)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)

    def forward(self, text: str) -> torch.Tensor:
        inputs = self.tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=512)
        inputs = {k: v.to(self.device) for k, v in inputs.items()}
        with torch.no_grad():
            outputs = self.model(**inputs)
        return outputs.last_hidden_state[:, 0, :] 

class ImageEncoder(nn.Module):
    def __init__(self):
        super().__init__()
        self.model = models.resnet50(weights=models.ResNet50_Weights.DEFAULT)
        self.model = nn.Sequential(*list(self.model.children())[:-1]) 
        self.model.eval()
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)
        self.transform = transforms.Compose([
            transforms.Resize(256),
            transforms.CenterCrop(224),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ])

    def forward(self, image_path: str) -> torch.Tensor:
        try:
            image = Image.open(image_path).convert('RGB')
            image = self.transform(image).unsqueeze(0) 
            image = image.to(self.device)
            with torch.no_grad():
                embedding = self.model(image)
            return embedding.squeeze() 
        except Exception as e:
            print(f"Error processing image {image_path}: {e}")
            return torch.zeros(IMAGE_ENCODER_EMBEDDING_DIM).to(self.device)


class MultimodalFusionModel(nn.Module):
    def __init__(self, text_embedding_dim: int, image_embedding_dim: int, num_classes: int, hidden_dim: int = 512):
        super().__init__()
        self.fusion_layer = nn.Linear(text_embedding_dim + image_embedding_dim, hidden_dim)
        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(0.5)
        self.prediction_layer = nn.Linear(hidden_dim, num_classes)
        self.softmax = nn.Softmax(dim=-1)

    def forward(self, text_embedding: torch.Tensor, image_embedding: torch.Tensor) -> torch.Tensor:
        if text_embedding.ndim == 1:
            text_embedding = text_embedding.unsqueeze(0)
        if image_embedding.ndim == 1:
            image_embedding = image_embedding.unsqueeze(0)
            
        fused_embedding = torch.cat((text_embedding, image_embedding), dim=1)
        x = self.fusion_layer(fused_embedding)
        x = self.relu(x)
        x = self.dropout(x)
        output_logits = self.prediction_layer(x)
        output_probs = self.softmax(output_logits)
        return output_probs.squeeze()

class MultimodalAI:
    def __init__(self, target_diseases: List[str]):
        self.text_encoder = TextEncoder()
        self.image_encoder = ImageEncoder()
        self.target_diseases = target_diseases
        self.fusion_model = MultimodalFusionModel(
            TEXT_ENCODER_EMBEDDING_DIM, 
            IMAGE_ENCODER_EMBEDDING_DIM, 
            len(target_diseases)
        )
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.fusion_model.to(self.device)

    def predict(self, text_symptoms: str, image_path: str) -> Tuple[List[Tuple[str, float]], Dict[str, Any]]:
        text_embedding = self.text_encoder(text_symptoms)
        image_embedding = self.image_encoder(image_path)

        text_embedding = text_embedding.to(self.device)
        image_embedding = image_embedding.to(self.device)

        if image_embedding.shape[0] != IMAGE_ENCODER_EMBEDDING_DIM:
             image_embedding = image_embedding.view(-1) # Flatten if it's [1, 2048] or [2048, 1, 1]
             if image_embedding.shape[0] != IMAGE_ENCODER_EMBEDDING_DIM: # Pad or truncate if necessary after flatten
                 new_embedding = torch.zeros(IMAGE_ENCODER_EMBEDDING_DIM).to(self.device)
                 size_to_copy = min(image_embedding.shape[0], IMAGE_ENCODER_EMBEDDING_DIM)
                 new_embedding[:size_to_copy] = image_embedding[:size_to_copy]
                 image_embedding = new_embedding


        probabilities = self.fusion_model(text_embedding, image_embedding)
        
        ranked_predictions = sorted(
            zip(self.target_diseases, probabilities.tolist()),
            key=lambda x: x[1],
            reverse=True
        )
        
        extracted_features = {
            "text_embedding": text_embedding.cpu().numpy().tolist(),
            "image_embedding": image_embedding.cpu().numpy().tolist(),
            "raw_text": text_symptoms
        }
        return ranked_predictions, extracted_features

class KnowledgeBase:
    def __init__(self, kb_data: Dict[str, Any] = None):
        if kb_data is None:
            self.kb = self._load_default_kb()
        else:
            self.kb = kb_data
        
        self.all_symptoms = set()
        for disease_info in self.kb.values():
            if "symptoms" in disease_info:
                self.all_symptoms.update([s.lower() for s in disease_info["symptoms"]])
            if "visual_cues" in disease_info: # Treat visual cues similarly to symptoms for keyword search
                 self.all_symptoms.update([vc.lower() for vc in disease_info["visual_cues"]])


    def _load_default_kb(self) -> Dict[str, Any]:
        return {
            "Influenza": {
                "symptoms": ["fever", "cough", "sore throat", "body aches", "fatigue", "chills", "headache"],
                "visual_cues": [],
                "description": "Influenza is a viral infection that attacks your respiratory system â€” your nose, throat and lungs. Commonly called the flu.",
                "urgency": "medium",
                "common_in_age_group": "all",
                "recommendation": "Rest, drink fluids, and consider over-the-counter pain relievers. See a doctor if symptoms are severe or if you are in a high-risk group."
            },
            "Lyme Disease": {
                "symptoms": ["fever", "fatigue", "headache", "muscle aches", "joint pain"],
                "visual_cues": ["bullseye rash", "circular rash", "expanding rash"],
                "description": "Lyme disease is a bacterial infection transmitted by infected ticks, characterized by fever, headache, fatigue, and a skin rash called erythema migrans.",
                "urgency": "high",
                "common_in_age_group": "all",
                "recommendation": "Requires antibiotic treatment. Consult a doctor immediately if Lyme disease is suspected, especially after a tick bite or with a characteristic rash."
            },
            "Common Cold": {
                "symptoms": ["runny nose", "sore throat", "cough", "congestion", "sneezing", "mild body aches", "mild headache"],
                "visual_cues": [],
                "description": "The common cold is a viral infection of your nose and throat (upper respiratory tract).",
                "urgency": "low",
                "common_in_age_group": "all",
                "recommendation": "Rest, stay hydrated, and use over-the-counter remedies for symptom relief. Symptoms usually resolve within a week or two."
            },
            "Eczema": {
                "symptoms": ["itchy skin", "dry skin", "red patches", "scaly skin", "skin inflammation"],
                "visual_cues": ["red patches", "dry flaky skin", "thickened skin", "small raised bumps"],
                "description": "Eczema (atopic dermatitis) is a condition that makes your skin red and itchy. It's common in children but can occur at any age.",
                "urgency": "low-medium",
                "common_in_age_group": "all",
                "recommendation": "Moisturize regularly, avoid irritants, and use topical corticosteroids if prescribed by a doctor. See a doctor for diagnosis and management plan."
            },
            "Conjunctivitis": {
                "symptoms": ["eye redness", "itchy eyes", "gritty feeling in eye", "eye discharge", "watery eyes"],
                "visual_cues": ["red eyes", "pink eyes", "swollen eyelids", "eye discharge (watery or thick)"],
                "description": "Conjunctivitis, or pink eye, is an inflammation or infection of the transparent membrane (conjunctiva) that lines your eyelid and covers the white part of your eyeball.",
                "urgency": "medium",
                "common_in_age_group": "all",
                "recommendation": "Depends on the cause (viral, bacterial, allergic). See a doctor for diagnosis. Practice good hygiene to prevent spread."
            },
            "Bronchitis": {
                "symptoms": ["cough", "mucus production", "fatigue", "shortness of breath", "mild fever", "chest discomfort"],
                "visual_cues": [],
                "description": "Bronchitis is an inflammation of the lining of your bronchial tubes, which carry air to and from your lungs.",
                "urgency": "medium",
                "recommendation": "Rest, fluids, humidifier. See a doctor if cough is severe, lasts weeks, or if you have underlying lung conditions."
            },
            "Pneumonia": {
                "symptoms": ["cough", "fever", "chills", "difficulty breathing", "chest pain", "fatigue"],
                "visual_cues": [],
                "description": "Pneumonia is an infection that inflames the air sacs in one or both lungs. The air sacs may fill with fluid or pus.",
                "urgency": "high",
                "recommendation": "Seek medical attention promptly. Treatment depends on the type and severity."
            },
            "Skin Allergy": {
                "symptoms": ["rash", "itchiness", "redness", "swelling", "bumps", "blisters"],
                "visual_cues": ["hives", "contact dermatitis rash", "localized redness", "swelling"],
                "description": "A skin allergy occurs when your skin reacts to an allergen, causing a rash or other symptoms.",
                "urgency": "low-medium",
                "recommendation": "Avoid the allergen. Use antihistamines or topical creams. See a doctor for persistent or severe reactions."
            },
             "Gastroenteritis": {
                "symptoms": ["diarrhea", "vomiting", "nausea", "abdominal cramps", "stomach pain", "mild fever"],
                "visual_cues": [],
                "description": "Gastroenteritis is an inflammation of the stomach and intestines, typically caused by a viral or bacterial infection.",
                "urgency": "medium",
                "recommendation": "Stay hydrated with plenty of fluids. Eat bland foods. Rest. See a doctor if symptoms are severe, persistent, or if there are signs of dehydration."
            }
        }
    
    def get_disease_info(self, disease_name: str) -> Dict[str, Any]:
        return self.kb.get(disease_name, {})

    def get_symptoms_for_disease(self, disease_name: str) -> List[str]:
        return self.kb.get(disease_name, {}).get("symptoms", [])
        
    def get_visual_cues_for_disease(self, disease_name: str) -> List[str]:
        return self.kb.get(disease_name, {}).get("visual_cues", [])

    def get_all_known_symptoms(self) -> set:
        return self.all_symptoms

class ReasoningEngine:
    def __init__(self, knowledge_base: KnowledgeBase):
        self.kb = knowledge_base

    def refine_predictions(self, 
                           ai_predictions: List[Tuple[str, float]], 
                           extracted_text_symptoms: List[str],
                           user_demographics: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        
        refined_list = []

        for disease_name, ai_confidence in ai_predictions:
            disease_info = self.kb.get_disease_info(disease_name)
            if not disease_info:
                continue

            kb_symptoms = [s.lower() for s in disease_info.get("symptoms", [])]
            kb_visual_cues = [vc.lower() for vc in disease_info.get("visual_cues", [])]
            
            current_score = ai_confidence
            matching_symptoms_count = 0
            reasoning_notes = [f"AI initial confidence: {ai_confidence:.2f}"]

            for user_symptom in extracted_text_symptoms:
                if user_symptom in kb_symptoms or user_symptom in kb_visual_cues:
                    matching_symptoms_count += 1
                    current_score += 0.05 
            
            if matching_symptoms_count > 0:
                 reasoning_notes.append(f"Found {matching_symptoms_count} matching symptom(s)/cue(s) in KB: {', '.join(list(set(extracted_text_symptoms) & (set(kb_symptoms) | set(kb_visual_cues))))}.")
            else:
                current_score -= 0.05 # Slight penalty if no reported symptoms match KB symptoms for an AI predicted disease
                reasoning_notes.append("No direct textual symptom matches in KB for this AI prediction.")


            current_score = min(max(current_score, 0.0), 1.0) # Clamp score between 0 and 1

            if current_score < 0.1 and ai_confidence < 0.2: # Filter out very low confidence unless strongly supported
                 continue


            refined_list.append({
                "name": disease_name,
                "score": round(current_score, 3),
                "description": disease_info.get("description", "No description available."),
                "kb_symptoms": disease_info.get("symptoms", []),
                "kb_visual_cues": disease_info.get("visual_cues", []),
                "urgency": disease_info.get("urgency", "Unknown"),
                "recommendation": disease_info.get("recommendation", "Consult a healthcare professional."),
                "reasoning_notes": reasoning_notes
            })

        refined_list.sort(key=lambda x: x["score"], reverse=True)
        return refined_list


class SymptoLens:
    def __init__(self):
        self.target_diseases_list = TARGET_DISEASES
        self.multimodal_ai = MultimodalAI(target_diseases=self.target_diseases_list)
        self.knowledge_base = KnowledgeBase()
        self.reasoning_engine = ReasoningEngine(self.knowledge_base)

    def _extract_keywords_from_text(self, text: str) -> List[str]:
        words = set(text.lower().replace(",", "").replace(".", "").split())
        known_symptoms_db = self.knowledge_base.get_all_known_symptoms()
        extracted = [symptom for symptom in known_symptoms_db if symptom in words or any(word in symptom for word in words if len(word)>3)] # Basic matching
        
        # More sophisticated matching:
        # If "eye is red" and "red eye" is in KB, it should match.
        # This is a simplification. True NER would be better.
        unique_extracted_keywords = []
        processed_text_tokens = text.lower().split()
        for kb_symptom in known_symptoms_db:
            if kb_symptom in text.lower(): # phrase matching
                 if kb_symptom not in unique_extracted_keywords:
                    unique_extracted_keywords.append(kb_symptom)
            else: # token matching
                kb_symptom_tokens = kb_symptom.split()
                if all(token in processed_text_tokens for token in kb_symptom_tokens):
                     if kb_symptom not in unique_extracted_keywords:
                        unique_extracted_keywords.append(kb_symptom)

        return list(set(unique_extracted_keywords))


    def assess(self, user_text_symptoms: str, image_path: str, user_demographics: Dict = None) -> Dict[str, Any]:
        if user_demographics is None:
            user_demographics = {}

        ai_predictions, ai_extracted_features = self.multimodal_ai.predict(user_text_symptoms, image_path)
        
        extracted_keywords = self._extract_keywords_from_text(ai_extracted_features["raw_text"])
        
        refined_results = self.reasoning_engine.refine_predictions(
            ai_predictions,
            extracted_keywords,
            user_demographics
        )
        
        final_output = {
            "user_input_text": user_text_symptoms,
            "user_input_image": image_path,
            "extracted_textual_symptoms": extracted_keywords,
            "ai_initial_predictions": ai_predictions,
            "refined_conditions": refined_results,
            "disclaimer": "DISCLAIMER: SymptoLens provides a preliminary assessment based on AI and a knowledge base. It is NOT a substitute for professional medical advice, diagnosis, or treatment. Always seek the advice of your physician or other qualified health provider with any questions you may have regarding a medical condition.",
            "timestamp": torch.cuda.is_available() # Placeholder for actual timestamp, using cuda availability for demo
        }
        return final_output


if __name__ == '__main__':
    sympto_lens_app = SymptoLens()

    # Create a dummy image file for testing
    try:
        dummy_image = Image.new('RGB', (100, 100), color = 'red')
        dummy_image_path = "dummy_symptom_image.png"
        dummy_image.save(dummy_image_path)
    except Exception as e:
        print(f"Could not create dummy image: {e}")
        dummy_image_path = None


    if dummy_image_path:
        print("\n--- Test Case 1: Flu-like symptoms ---")
        test_text_1 = "I have a high fever, body aches, and a persistent cough for three days. I also feel very tired."
        test_image_1 = dummy_image_path # Using dummy image
        assessment_1 = sympto_lens_app.assess(test_text_1, test_image_1)
        
        print(f"Input Text: {assessment_1['user_input_text']}")
        print(f"Extracted Keywords: {assessment_1['extracted_textual_symptoms']}")
        print("Refined Conditions:")
        for condition in assessment_1['refined_conditions'][:3]: # Show top 3
            print(f"  - Name: {condition['name']}, Score: {condition['score']:.3f}, Urgency: {condition['urgency']}")
            print(f"    Description: {condition['description']}")
            print(f"    Recommendation: {condition['recommendation']}")
            # print(f"    Reasoning: {condition['reasoning_notes']}")
        print(assessment_1['disclaimer'])

        print("\n--- Test Case 2: Skin rash ---")
        test_text_2 = "My skin has a red itchy rash that looks like small bumps. It appeared after hiking in the woods. It's somewhat circular."
        test_image_2 = dummy_image_path # Using dummy image (ideally a real rash image)
        assessment_2 = sympto_lens_app.assess(test_text_2, test_image_2)

        print(f"Input Text: {assessment_2['user_input_text']}")
        print(f"Extracted Keywords: {assessment_2['extracted_textual_symptoms']}")
        print("Refined Conditions:")
        for condition in assessment_2['refined_conditions'][:3]:
            print(f"  - Name: {condition['name']}, Score: {condition['score']:.3f}, Urgency: {condition['urgency']}")
            print(f"    Description: {condition['description']}")
            print(f"    Recommendation: {condition['recommendation']}")
            # print(f"    Reasoning: {condition['reasoning_notes']}")
        print(assessment_2['disclaimer'])

        print("\n--- Test Case 3: Eye problem ---")
        test_text_3 = "My left eye is very red and itchy. It feels gritty, and there's some watery discharge."
        test_image_3 = dummy_image_path # Using dummy image
        assessment_3 = sympto_lens_app.assess(test_text_3, test_image_3)

        print(f"Input Text: {assessment_3['user_input_text']}")
        print(f"Extracted Keywords: {assessment_3['extracted_textual_symptoms']}")
        print("Refined Conditions:")
        for condition in assessment_3['refined_conditions'][:3]:
            print(f"  - Name: {condition['name']}, Score: {condition['score']:.3f}, Urgency: {condition['urgency']}")
            print(f"    Description: {condition['description']}")
            print(f"    Recommendation: {condition['recommendation']}")
            # print(f"    Reasoning: {condition['reasoning_notes']}")
        print(assessment_3['disclaimer'])

    else:
        print("Dummy image could not be created. Skipping example runs.")